"""
작성일: 2020-08-18
==============================================================================
문제 위치: 교재 92p
==============================================================================
소요 시간: 47분
"""

# n, m, k 입력
n, m , k = map(int, input("").split())

# 리스트 입력
num_list = list(map(int, input("").split()))

max_num = 0
max_num_index = -1
second_max_num = 0

# 첫번째로 큰 수와 두번째로 큰 수 찾기
for item in num_list:
    if item > max_num:
        max_num = item
        max_num_index = item.__index__  
        # 최대 숫자의 인덱스 기억. 
        # 숫자 자체가 아닌 인덱스를 기억하는 이유는 같은 숫자라도 다른 인덱스라면 다른 숫자로 취급하기 때문.

for item in num_list:
    if item != max_num_index and item > second_max_num:
    # 최대 숫자 인덱스와 다른 인덱스의 숫자 중에서 최대 숫자 구함
        second_max_num = item

# 출력할 결과값 변수
result = 0

# k번까지만 최대 숫자를 더하기 위한 카운트 변수
cooldown = k
for i in range(m):    # m번 더하기 진행
    if cooldown > 0:  # 만약 최대숫자를 더할 수 있는 횟수가 남았을 경우 최대숫자를 더함
        result += max_num
        cooldown -= 1
    else:             # 만약 최대숫자를 더할 수 있는 횟수가 없을 경우 두번째 큰 숫자를 더하고 cooldown 초기화
        result += second_max_num
        cooldown = k

# 결과 출력
print(result)


"""
접근법: 
무슨 일이 있어도 '가장 큰 수'와 '두번째로 큰 수'만 덧셈에 사용된다 라는 것을 파악했고,
따라서 가장 큰 수와 두번째로 큰 수를 먼저 구하고
m번만큼 가장 큰 수의 덧셈을 진행하되 k+1번째마다 두번째로 큰 수를 한번씩 더하면 된다고 생각했다.

단, 인덱스가 다르면 숫자의 크기가 같아도 다른 수로 취급하는 것을 보고
두번째 큰 수를 구할 때, 숫자 자체가 아닌 인덱스를 비교하는 로직을 세웠다.

마지막으로 덧셈이 진행되는 루프에서,
cooldown이라는 변수를 사용해 k+1번째마다 두번째로 큰 수가 더해지도록 분기를 나눴다.
==============================================================================
개선점: 
- 알고리즘 문제가 처음이라 그런가 시간이 오래 걸렸다.
- 입력을 받을 때 크기 조건 비교를 하지 않았다.
- 입력을 받을 때 입력값이 숫자인지 비교하지 않았다.
- List의 sort() 함수를 사용했으면 리스트 정렬을 해서 가장 큰 수와 두번째로 큰 수를 더 쉽게 찾을 수 있었다.
==============================================================================
코멘트: 스터디 조원들의 코멘트
"""